/* ОБЪЯВЛЕНИЕ */

let arr = new Array();
let fruits = ['Яблоко', 'Апельсин', 'Слива']; //Список элементов массива, как и список свойств объекта, может оканчиваться запятой

console.log(fruits[0]); // Яблоко. Мы можем получить элемент, указав его номер в квадратных скобках
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]. Мы можем заменить элемент
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]. Или добавить новый к существующему массиву
console.log(fruits.length); // 3. Общее число элементов массива содержится в его свойстве length

/* МЕТОДЫ, РАБОТАЮЩИЕ С КОНЦОМ МАССИВА */

// pop - Удаляет последний элемент из массива и возвращает его
// push - Добавляет элемент в конец массива

/* МЕТОДЫ, РАБОТАЮЩИЕ С НАЧАЛОМ МАССИВА */

// shift - Удаляет из массива первый элемент и возвращает его
// unshift - Добавляет элемент в начало массива
// Методы push и unshift могут добавлять сразу несколько элементов

/* ПЕРЕБОР ЭЛЕМЕНТОВ */

// проходит по значениям forof
for (let fruit of fruits) {
  console.log(fruit);
}

//Перебор: forEach
['Bilbo', 'Gandalf', 'Nazgul'].forEach((item, index, array) => {
  console.log(`${item} имеет позицию ${index} в ${array}`);
});

/* МНОГОМЕРНЫЕ МАССИВЫ */

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

console.log(matrix[1][1]); // 5, центральный элемент

/* toString */

// Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.
arr = [1, 2, 3];
console.log(arr); // 1,2,3

/* УДАЛИТЬ ЭЛЕМЕНТ ИЗ МАССИВА splice */

//arr.splice(index[, deleteCount, elem1, ..., elemN]) Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
let arr = ['Я', 'изучаю', 'JavaScript', 'прямо', 'сейчас'];
arr.splice(0, 3, 'Давай', 'танцевать'); // удалить 3 первых элемента и заменить их другими (Отрицательные индексы разрешены)
console.log(arr); // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// slice Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
let arr1 = ['t', 'e', 's', 't'];
console.log(arr1.slice(1, 3)); // e,s (копирует с 1 до 3)   slice без аргументов создаёт копию массива

//concat
//Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
let arr2 = [1, 2];
// создать массив из: arr и [3,4], потом добавить значения 5 и 6
console.log(arr2.concat([3, 4], 5, 6)); // 1,2,3,4,5,6

/* ПОИСК В МАССИВЕ */

// arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
// arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
// arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

//find и findIndex

// Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.
// Его синтаксис таков:
let result = arr.find(function (item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
// Функция вызывается по очереди для каждого элемента массива:
//     item – очередной элемент.
//     index – его индекс.
//     array – сам массив.
// Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.

//если найденных элементов может быть много, предусмотрен метод arr.filter(fn)
let results = arr.filter(function (item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

/* ПРЕОБРАЗОВАНИЕ МАССИВА */

//map
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
// Синтаксис:
let result = arr.map(function (item, index, array) {
  // возвращается новое значение вместо элемента
});

// sort(fn)

// Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. По умолчанию элементы сортируются как строки.

// reverse

// Метод arr.reverse меняет порядок элементов в arr на обратный.

// split и join

// Метод str.split(delim) разбивает строку на массив по заданному разделителю delim.
// Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.

// reduce/reduceRight

// Методы arr.reduce и arr.reduceRight используются для вычисления какого-нибудь единого значения на основе всего массива.

// Синтаксис:
let value = arr.reduce(function (previousValue, item, index, array) {}, [
  initial,
]);
// Аргументы:

//     previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
//     item – очередной элемент массива,
//     index – его индекс,
//     array – сам массив.
// Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево

// Array.isArray
// Он возвращает true, если value массив, и false, если нет.
