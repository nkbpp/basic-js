/* ОБЪЕКТЫ */

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {}; // синтаксис "литерал объекта"

// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

let user = {
    // объект
    name: 'John', // под ключом "name" хранится значение "John"
    age: 30, // под ключом "age" хранится значение 30 Последнее свойство объекта может заканчиваться запятой
};

console.log(user);

// Для обращения к свойствам используется запись «через точку»:
console.log(user.age);
// альтернативный способ доступа к свойствам через квадратные скобки.
user['likes birds'] = true;
console.log(user['likes birds']);

// Давайте добавим свойство с логическим значением:
user.isAdmin = true;
console.log(user);

// Для удаления свойства мы можем использовать оператор delete:
delete user.age;
console.log(user);

/* ВЫЧИСЛЯЕМЫЕ СВОЙСТВА */

/* let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
alert( bag.apple ); // 5, если fruit="apple" */
// Мы можем использовать и более сложные выражения в квадратных скобках
// Квадратные скобки дают намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

//короткая запись если имя переменной соответствет значению
let a = 15;
let A = {
    a, // a: a,
    b: 14,
};
console.log(A);

// Проверка существования свойства, оператор «in»

let user1 = { name: 'John', age: 30 };

console.log('age' in user1); // user.age === undefined
// В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда свойство существует, но содержит значение undefined, и нужно использовать "in".

/* Цикл «for…in» */

for (let key in user) {
    // ключи
    console.log(key);
    // значения ключей
    console.log(user[key]);
}

// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

/* КЛОНИРОВАНИЕ И ОБЪЕДИНЕНИЕ ОБЪЕКТОВ, Object.assign */

// Object.assign(dest, [src1, src2, src3...]) Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект. Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
let clone = Object.assign({}, user); //Этот метод скопирует все свойства объекта user в пустой объект и возвратит его, работает если свойства объекта user хранят примитивные значения
// Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
