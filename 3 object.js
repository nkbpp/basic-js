//! ОБЪЕКТЫ

let user1 = new Object(); // синтаксис "конструктор объекта"
let user2 = {}; // синтаксис "литерал объекта"

// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

let user3 = {
  // объект
  name: 'John', // под ключом "name" хранится значение "John"
  age: 30, // под ключом "age" хранится значение 30 Последнее свойство объекта может заканчиваться запятой
};
console.log(user3);

//! Деструктуризация объекта

let options = {
  title: 'Menu',
  width: 100,
  height: 200,
};
let { width: w, height: h, title } = options;
console.log(title); // Menu
console.log(w); // 100
console.log(h); // 200

//! Для обращения к свойствам используется запись «через точку»:
console.log(user3.age);
//! альтернативный способ доступа к свойствам через квадратные скобки.
user3['likes birds'] = true;
console.log(user3['likes birds']);

// Давайте добавим свойство с логическим значением:
user3.isAdmin = true;
console.log(user3);

//! Для удаления свойства мы можем использовать оператор delete:
delete user.age;
console.log(user);

//!  ВЫЧИСЛЯЕМЫЕ СВОЙСТВА

/* let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
alert( bag.apple ); // 5, если fruit="apple" */
// Мы можем использовать и более сложные выражения в квадратных скобках
// Квадратные скобки дают намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

//короткая запись если имя переменной соответствет значению
let a = 15;
let A = {
  a, // a: a,
  b: 14,
};
console.log(A);

//! Проверка существования свойства, оператор «in»

console.log('age' in user3); // user.age === undefined
// В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда свойство существует, но содержит значение undefined, и нужно использовать "in".

//! Цикл «for…in»

for (let key in user3) {
  // ключи
  console.log(key);
  // значения ключей
  console.log(user3[key]);
}

// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

//! КЛОНИРОВАНИЕ И ОБЪЕДИНЕНИЕ ОБЪЕКТОВ, Object.assign

// Object.assign(dest, [src1, src2, src3...]) Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект. Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
let clone = Object.assign({}, user3); //Этот метод скопирует все свойства объекта user в пустой объект и возвратит его, работает если свойства объекта user хранят примитивные значения
// Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

/* Преобразование объектов в примитивы */
//Все объекты в логическом контексте являются true
